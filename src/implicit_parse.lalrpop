use common::Id;
use common::Op2::*;
use common::Const::*;
use implicit::Expr;
use implicit::Expr::*;
use tok::{self, Tok};

#[LALR]
grammar<'input>(text: &'input str);

pub Program: Box<Expr> = {
    Expr,
};

Expr: Box<Expr> = {
    "if" <c:Expr> "then" <t:Expr> "else" <f:Expr>    => Box::new(If(c, t, f)),
    "let" <id:Ident> "=" <v:Expr> "in" <e:Expr>      => Box::new(Let(id, v, e)),
    "let" "rec" <f:Ident> "=" <v:Expr> "in" <e:Expr> => Box::new(Let(f.clone(), Box::new(Fix(f, v)), e)),
    "fun" <id:Ident> "->" <e:Expr>                   => Box::new(Fun(id, e)),
    "fix" <id:Ident> "->" <e:Expr>                   => Box::new(Fix(id, e)),
    "begin" <e:Expr> "end"                           => e,
    LCmp,
};

LCmp: Box<Expr> = {
    <l:ACmp> "∧" <r:LCmp> => Box::new(Op2(And, l, r)),
    <l:ACmp> "∨" <r:LCmp> => Box::new(Op2(Or, l, r)),
    ACmp,
};

ACmp: Box<Expr> = {
    <l:Add> "=" <r:ACmp>  => Box::new(Op2(Eq, l, r)),
    <l:Add> "<" <r:ACmp>  => Box::new(Op2(LT, l, r)),
    <l:Add> "<=" <r:ACmp> => Box::new(Op2(LTE, l, r)),
    <l:Add> ">" <r:ACmp>  => Box::new(Op2(GT, l, r)),
    <l:Add> ">=" <r:ACmp> => Box::new(Op2(GTE, l, r)),
    Add,
};

Add: Box<Expr> = {
    <l:Add> "-" <r:Mul> => Box::new(Op2(Sub, l, r)),
    <l:Add> "+" <r:Mul> => Box::new(Op2(Add, l, r)),
    Mul,
};

Mul: Box<Expr> = {
    <l:Mul> "*" <r:Get> => Box::new(Op2(Mul, l, r)),
    Get,
};

Get: Box<Expr> = {
    <id:Ident> "[" <idx:Add> "]" "<-" <e:Atom> => Box::new(SetArray(Box::new(Var(id)), idx, e)),
    <id:Ident> "[" <idx:Add> "]"               => Box::new(GetArray(Box::new(Var(id)), idx)),
    App,
};

App: Box<Expr> = {
    "array" "(" <sz:Add> "," <n:Add> ")" => Box::new(MkArray(sz, n)),
    "!" <a:Atom>                         => Box::new(App(Box::new(Var(String::from("not"))), a)),
    <a:App> <b:Atom>                     => Box::new(App(a, b)),
    Atom,
};

Atom: Box<Expr> = {
    <id:Ident>    => Box::new(Var(id)),
    "ν"           => Box::new(V),
    "★"           => Box::new(Star),
    "true"        => Box::new(Const(Bool(true))),
    "false"       => Box::new(Const(Bool(true))),
    "(" <Exprs> ")",
    Int,
};

Exprs: Box<Expr> = {
    Expr,
};

Int: Box<Expr> = {
    Num => Box::new(Const(Int(<>))),
};

Ident: Id = {
    <id:"Iden"> => String::from(id),
};

Num: i64 = {
    "Num",
};

extern {
    type Location = usize;
    type Error = tok::Error;
    enum Tok<'input> {
        "if" => Tok::If,
        "then" => Tok::Then,
        "else" => Tok::Else,
        "begin" => Tok::Begin,
        "end" => Tok::End,
        "let" => Tok::Let,
        "in" => Tok::In,
        "," => Tok::Comma,
        "=" => Tok::Eq,
        "->" => Tok::RArrow,
        "<-" => Tok::LArrow,
        "<" => Tok::Lt,
        "<=" => Tok::Lte,
        ">" => Tok::Gt,
        ">=" => Tok::Gte,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Mul,
        "!" => Tok::Exclaim,
        "::" => Tok::Cons,
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "[" => Tok::LBracket,
        "]" => Tok::RBracket,
        "fun" => Tok::Fun,
        "fix" => Tok::Fix,
        "head" => Tok::Head,
        "tail" => Tok::Tail,
        "empty?" => Tok::Emptyq,
        "true" => Tok::True,
        "false" => Tok::False,
        "empty" => Tok::Empty,
        "array" => Tok::Array,
        "set" => Tok::Set,
        "rec" => Tok::Rec,
        "ν" => Tok::V,
        "★" => Tok::Star,
        "∧" => Tok::And,
        "∨" => Tok::Or,

        "Iden" => Tok::Ident(<&'input str>),
        "Num" => Tok::Num(<i64>),
    }
}
